### jvm的基础概念jvm，是一个虚拟机，java之所以能跨平台是因为java是编译成class文件之后在jvm上去运行的。所以java代码的运行不依赖与平台（系统）只依赖与jvm。

jvm运行的是class文件，只要能编译成class文件的代码jvm都能运行，并不只能运行java这一种语言。

### 类的加载（创建Class对象）

java类是通过ClassLoader来进行加载的。类的加载过程是双亲委派，先判断自己是否加载过若没有加载传递给父加载器去判断。父加载器判断的过程中发现加载过就直接返回；若顶级父加载器（c++实现的）也没有加载就尝试加载，无法加载传递给子加载器。若子加载器无法加载报错；

双亲委派的实现是ClassLoader抽象类中的模板方法loadClass，若要打破双亲委派在自定义classloader的之后重写改方法即可。

classLoader的父加载器并不是继承的而是类中的一个属性 “parent” 

#### java自带的ClassLoader有三个

1.用c++实现的classLoader（这个类在java代码中是不存在的）  

2.ExtClassLoader

3.AppletClassLoader

#### 自定义classLoader

自定义classLoader需要继承ClassLoader若要延用双亲委派只需重写findClass方法即可，读取需要加载的文件调用defineClass进行类的加载。（百度实现细节）

应用场景：代码加密，对正常编译的class文件进行加密，甚至可以修改后缀名，在自定义类加载器进行解密加载。

打破双亲委派的应用场景，热编译。模板方法中的双亲委派同一个class只能加载一次无法实现热编译。

### 解释还是编译

jvm默认是混合执行模式即有解释也有编译。执行频率较高的热点代码会编译执行，其余代码为解释执行。可以设置虚拟机参数做成只编译或只解释执行。

### 垃圾回收

#### 回收算法

​	标记清除(mark-sweep)： 将被标记的垃圾直接清除，缺点会造成内存碎片化。 

​	拷贝(copaying)： 内存只用一半，满了之后将有效的对象复制到另一半，然后把被复制的一半直接清除。空间浪费。

​	标记压缩(mark-compact)：在标记清除之后将有用的对象移动到一起。不会造成内存碎片化。效率比拷贝略低。

#### 内存分代

新生代与老年代

新生代分为一个edan园区很两个幸存者区。新创建的对象会放到edan园区。经过一次ygc后会将存活的对象放到其中一个幸存者区。第二次ygc的时候会将edan园区和有对象的幸存者区一起进行回收，然后把留下来的放到另外的幸存者区。若幸存者区满了新创建的对象会直接进入老年代。当一次对象被多次ygc后还是没有被请你掉就会进入老年代。老年代满之后进行ogc。

#### G1

随着计算机硬件和业务量的升级。传统的分代模式在大内存的情况下效率开始降低。g1回收器不在进行物理上的分区。而是进行逻辑分区。将内存分为多个小块，每次回收只回收几个小块使得效率进行得到提升。任意一个小块可以是新生代也可以是老年代可以随意转换。即在调优时不需要手动指定各代的大小。

#### 三色标记

已经处理过的为灰色 所有子节点都是灰色就变成黑色。